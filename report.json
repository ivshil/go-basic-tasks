{"stats":{"totalMutantsCount":148,"killedCount":61,"notCoveredCount":0,"escapedCount":87,"errorCount":0,"skippedCount":0,"timeOutCount":0,"msi":0.41216216216216217,"mutationCodeCoverage":0,"coveredCodeMsi":0},"escaped":[{"mutator":{"mutatorName":"loop/break","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -81,7 +81,7 @@\n \t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n \t\t\t\tisDuplicate = true\n-\t\t\t\tbreak\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \t\tif !isDuplicate {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.17\" with checksum f07fa200438ca15e3124bfc1c7633033\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{0, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{0, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.23\" with checksum ad611b71faf36ba5661c76293d882dac\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 0, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 0, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.24\" with checksum 58ca207d8fe24a96711aab45a84cb66b\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 1, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 1, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.25\" with checksum 9b4bfb1b165417b26a58fb476c9c2222\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 2, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 2, 0, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.26\" with checksum 2fbae0e731043cd0f0815e12da1f00cf\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, -1, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, -1, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.27\" with checksum b67d966a7faaa22a63012143c5ffe355\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 4, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 4, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.28\" with checksum 69981651eecd45fabf9e3591f3c2090f\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 6, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 6, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.29\" with checksum 362e14e83a782aacef020c005b1f6b51\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 2, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 2, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.30\" with checksum c2645ee60145810df16cae73f69aad0e\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 4, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 4, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.31\" with checksum c2569778a076cb310305afc260047f50\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 3, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 3, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.32\" with checksum cd8e96a954914c3f7d8afb5332371e21\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 7, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 7, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.33\" with checksum 91bba3ffbfddf68335e9c42b508d79ae\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 89}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 89}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.34\" with checksum 57f15aaa35624e26da126adb21c63ed0\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  4,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -10,7 +10,7 @@\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n-\t\t\"apple\":  5,\n+\t\t\"apple\":  4,\n \t\t\"banana\": 3,\n \t\t\"orange\": 2,\n \t\t\"peach\":  4,\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.35\" with checksum d33650b2bc26260792103fd46f0872d8\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 2,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -11,7 +11,7 @@\n \n \tmapA := map[string]int{\n \t\t\"apple\":  5,\n-\t\t\"banana\": 3,\n+\t\t\"banana\": 2,\n \t\t\"orange\": 2,\n \t\t\"peach\":  4,\n \t}\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.36\" with checksum 7c92271a583f55f12265327e0b002b0e\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 1,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -12,7 +12,7 @@\n \tmapA := map[string]int{\n \t\t\"apple\":  5,\n \t\t\"banana\": 3,\n-\t\t\"orange\": 2,\n+\t\t\"orange\": 1,\n \t\t\"peach\":  4,\n \t}\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.37\" with checksum 9f13c54170ee3917a524b8867928abd5\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  3,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -13,7 +13,7 @@\n \t\t\"apple\":  5,\n \t\t\"banana\": 3,\n \t\t\"orange\": 2,\n-\t\t\"peach\":  4,\n+\t\t\"peach\":  3,\n \t}\n \n \tmapB := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.38\" with checksum b9b6c3c148dee313aba653c0fe7e787d\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   2,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -17,7 +17,7 @@\n \t}\n \n \tmapB := map[string]int{\n-\t\t\"apple\":   3,\n+\t\t\"apple\":   2,\n \t\t\"orange\":  2,\n \t\t\"tomatoe\": 12,\n \t\t\"coconut\": 1,\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.39\" with checksum 278bc5793dc15803962e0f9feb649e8a\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  1,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -18,7 +18,7 @@\n \n \tmapB := map[string]int{\n \t\t\"apple\":   3,\n-\t\t\"orange\":  2,\n+\t\t\"orange\":  1,\n \t\t\"tomatoe\": 12,\n \t\t\"coconut\": 1,\n \t}\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.40\" with checksum 237146b782c7ca795f0e1c1b771ffaa2\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 11,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -19,7 +19,7 @@\n \tmapB := map[string]int{\n \t\t\"apple\":   3,\n \t\t\"orange\":  2,\n-\t\t\"tomatoe\": 12,\n+\t\t\"tomatoe\": 11,\n \t\t\"coconut\": 1,\n \t}\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.41\" with checksum 7d0c745213934023b14d671574d92777\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 0,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -20,7 +20,7 @@\n \t\t\"apple\":   3,\n \t\t\"orange\":  2,\n \t\t\"tomatoe\": 12,\n-\t\t\"coconut\": 1,\n+\t\t\"coconut\": 0,\n \t}\n \n \trectangle := models.Rectangle{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.42\" with checksum 5ced5caa30abb84d8648a286267620c7\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  123,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -24,7 +24,7 @@\n \t}\n \n \trectangle := models.Rectangle{\n-\t\tWidth:  124,\n+\t\tWidth:  123,\n \t\tHeight: 351,\n \t}\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.43\" with checksum dcf9c13a528b85198c455f078adb9723\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 350,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n \n \trectangle := models.Rectangle{\n \t\tWidth:  124,\n-\t\tHeight: 351,\n+\t\tHeight: 350,\n \t}\n \n \tcircle := models.Cyrcle{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.44\" with checksum f466aac95fb16e7f923054c03bd6737c\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 33,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -29,7 +29,7 @@\n \t}\n \n \tcircle := models.Cyrcle{\n-\t\tRadius: 34,\n+\t\tRadius: 33,\n \t}\n \n \tfmt.Println(removeDuplicates(sliceOfInt))\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.45\" with checksum d3e69412f6780d0a85f495f52fcc1b9c\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   24,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -48,7 +48,7 @@\n \n \tperson := models.Person{\n \t\tName:  \"John Doe\",\n-\t\tAge:   25,\n+\t\tAge:   24,\n \t\tEmail: \"johndoe@example.org\",\n \t}\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.46\" with checksum c371498214da2f545bcac8d11ef4b912\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 0; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -76,7 +76,7 @@\n \tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n \tvar isDuplicate bool\n \n-\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n+\tfor i := 0; i \u003c len(sliceOfInts); i++ {\n \t\tisDuplicate = false\n \t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.51\" with checksum 32b1fe78f2db54b2e58498eea93b13e7\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{2, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{2, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.56\" with checksum 21ad55be6cf2818471ed9b53c3a964a4\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 2, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 2, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.57\" with checksum 28fdced493dc5a40a0e8c1e893630659\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 3, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 3, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.58\" with checksum d67583aecdb358b790afacbe9bed20cc\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 4, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 4, 0, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.59\" with checksum 128134dea5a3a418526f1c0158f49286\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 1, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 1, 5, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.60\" with checksum 4c2cecf3deef49b980d1bf740d489761\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 6, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 6, 7, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.61\" with checksum caa0828256340a0f56677bf1841df8a5\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 8, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 8, 3, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.62\" with checksum d330d8c0f0bcc7feb37c049f1b4cfe79\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 4, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 4, 5, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.63\" with checksum 816458182a9d55a1dc86d95596ccfa55\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 6, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 6, 4, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.64\" with checksum a3870fb4d6cb6afcdd28da06ba3689cd\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 5, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 5, 8, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.65\" with checksum 0bd5029055a48e73a49478cf34dab361\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 9, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 9, 90}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.66\" with checksum 95205a1d15bbafda3a481486e9a822fb\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 91}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -6,7 +6,7 @@\n )\n \n func main() {\n-\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n+\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 91}\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.67\" with checksum 1c1853a0d7a7839f4769ec76b2936722\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  6,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -10,7 +10,7 @@\n \tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n \n \tmapA := map[string]int{\n-\t\t\"apple\":  5,\n+\t\t\"apple\":  6,\n \t\t\"banana\": 3,\n \t\t\"orange\": 2,\n \t\t\"peach\":  4,\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.68\" with checksum 31cc6938931b274cbf9e4b57921acaf6\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 4,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -11,7 +11,7 @@\n \n \tmapA := map[string]int{\n \t\t\"apple\":  5,\n-\t\t\"banana\": 3,\n+\t\t\"banana\": 4,\n \t\t\"orange\": 2,\n \t\t\"peach\":  4,\n \t}\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.69\" with checksum 2906d292a94a197911dc7a56e9b1c01e\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 3,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -12,7 +12,7 @@\n \tmapA := map[string]int{\n \t\t\"apple\":  5,\n \t\t\"banana\": 3,\n-\t\t\"orange\": 2,\n+\t\t\"orange\": 3,\n \t\t\"peach\":  4,\n \t}\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.70\" with checksum 162fd5aaf5a475e225eaa0a0e3817ab9\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  5,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -13,7 +13,7 @@\n \t\t\"apple\":  5,\n \t\t\"banana\": 3,\n \t\t\"orange\": 2,\n-\t\t\"peach\":  4,\n+\t\t\"peach\":  5,\n \t}\n \n \tmapB := map[string]int{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.71\" with checksum bb7b24edbd55e7152d784f0e0321caf0\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   4,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -17,7 +17,7 @@\n \t}\n \n \tmapB := map[string]int{\n-\t\t\"apple\":   3,\n+\t\t\"apple\":   4,\n \t\t\"orange\":  2,\n \t\t\"tomatoe\": 12,\n \t\t\"coconut\": 1,\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.72\" with checksum ccdb87fa09eada47783623f5148bdd8b\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  3,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -18,7 +18,7 @@\n \n \tmapB := map[string]int{\n \t\t\"apple\":   3,\n-\t\t\"orange\":  2,\n+\t\t\"orange\":  3,\n \t\t\"tomatoe\": 12,\n \t\t\"coconut\": 1,\n \t}\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.73\" with checksum 49fc8d13e096f2d4e149a4eb1d3c2f9c\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 13,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -19,7 +19,7 @@\n \tmapB := map[string]int{\n \t\t\"apple\":   3,\n \t\t\"orange\":  2,\n-\t\t\"tomatoe\": 12,\n+\t\t\"tomatoe\": 13,\n \t\t\"coconut\": 1,\n \t}\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.74\" with checksum 1b03f893cd78d52592c1839985e8caf0\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 2,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -20,7 +20,7 @@\n \t\t\"apple\":   3,\n \t\t\"orange\":  2,\n \t\t\"tomatoe\": 12,\n-\t\t\"coconut\": 1,\n+\t\t\"coconut\": 2,\n \t}\n \n \trectangle := models.Rectangle{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.75\" with checksum cefd762f6335cdf6b68e6cab2312e2d8\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  125,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -24,7 +24,7 @@\n \t}\n \n \trectangle := models.Rectangle{\n-\t\tWidth:  124,\n+\t\tWidth:  125,\n \t\tHeight: 351,\n \t}\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.76\" with checksum 00d5c6c7c63574c584aad2da304270b1\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 352,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n \n \trectangle := models.Rectangle{\n \t\tWidth:  124,\n-\t\tHeight: 351,\n+\t\tHeight: 352,\n \t}\n \n \tcircle := models.Cyrcle{\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.77\" with checksum afa542877bfdb9f173a256c53e45c404\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 35,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -29,7 +29,7 @@\n \t}\n \n \tcircle := models.Cyrcle{\n-\t\tRadius: 34,\n+\t\tRadius: 35,\n \t}\n \n \tfmt.Println(removeDuplicates(sliceOfInt))\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.78\" with checksum 2438599cca86d4d81237eb0ea46f444d\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   26,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -48,7 +48,7 @@\n \n \tperson := models.Person{\n \t\tName:  \"John Doe\",\n-\t\tAge:   25,\n+\t\tAge:   26,\n \t\tEmail: \"johndoe@example.org\",\n \t}\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.79\" with checksum 10a52f92b3430f620b8ce246f6b5c972\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 1; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -78,7 +78,7 @@\n \n \tfor i := 1; i \u003c len(sliceOfInts); i++ {\n \t\tisDuplicate = false\n-\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n+\t\tfor j := 1; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n \t\t\t\tisDuplicate = true\n \t\t\t\tbreak\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.85\" with checksum af4a1f387bbdc7f680153014986b272b\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\t_, _ = fmt.Println, sliceOfInt\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -31,8 +31,7 @@\n \tcircle := models.Cyrcle{\n \t\tRadius: 34,\n \t}\n-\n-\tfmt.Println(removeDuplicates(sliceOfInt))\n+\t_, _ = fmt.Println, sliceOfInt\n \tfmt.Println(countOccurrences(sliceOfStr))\n \tfmt.Println(mergeMaps(mapA, mapB))\n \tfmt.Println(models.RectArea(rectangle))\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.89\" with checksum 14ea07ffbad5e8f3413878b3b0b4161b\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\t_, _ = fmt.Println, sliceOfStr\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n \t}\n \n \tfmt.Println(removeDuplicates(sliceOfInt))\n-\tfmt.Println(countOccurrences(sliceOfStr))\n+\t_, _ = fmt.Println, sliceOfStr\n \tfmt.Println(mergeMaps(mapA, mapB))\n \tfmt.Println(models.RectArea(rectangle))\n \tfmt.Println(models.RectPerimeter(rectangle))\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.90\" with checksum 4afba23b547ed371949101e63a1178ca\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\t_, _, _ = fmt.Println, mapA, mapB\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -34,7 +34,7 @@\n \n \tfmt.Println(removeDuplicates(sliceOfInt))\n \tfmt.Println(countOccurrences(sliceOfStr))\n-\tfmt.Println(mergeMaps(mapA, mapB))\n+\t_, _, _ = fmt.Println, mapA, mapB\n \tfmt.Println(models.RectArea(rectangle))\n \tfmt.Println(models.RectPerimeter(rectangle))\n \tfmt.Println(models.CircArea(circle))\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.91\" with checksum 15d0b478a6fab8a3fb77bcd2338bc2af\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\t_, _, _ = fmt.Println, models.RectArea, rectangle\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -35,7 +35,7 @@\n \tfmt.Println(removeDuplicates(sliceOfInt))\n \tfmt.Println(countOccurrences(sliceOfStr))\n \tfmt.Println(mergeMaps(mapA, mapB))\n-\tfmt.Println(models.RectArea(rectangle))\n+\t_, _, _ = fmt.Println, models.RectArea, rectangle\n \tfmt.Println(models.RectPerimeter(rectangle))\n \tfmt.Println(models.CircArea(circle))\n \tfmt.Println(models.Circumference(circle))\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.92\" with checksum 175a51d38d5752ddee2e4a30ecd70513\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\t_, _, _ = fmt.Println, models.RectPerimeter, rectangle\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -36,7 +36,7 @@\n \tfmt.Println(countOccurrences(sliceOfStr))\n \tfmt.Println(mergeMaps(mapA, mapB))\n \tfmt.Println(models.RectArea(rectangle))\n-\tfmt.Println(models.RectPerimeter(rectangle))\n+\t_, _, _ = fmt.Println, models.RectPerimeter, rectangle\n \tfmt.Println(models.CircArea(circle))\n \tfmt.Println(models.Circumference(circle))\n \tfmt.Println(\"Yabadabadu\")\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.93\" with checksum 4f93f801f075cd7e0836c91cc255fd6f\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\t_, _, _ = fmt.Println, models.CircArea, circle\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -37,7 +37,7 @@\n \tfmt.Println(mergeMaps(mapA, mapB))\n \tfmt.Println(models.RectArea(rectangle))\n \tfmt.Println(models.RectPerimeter(rectangle))\n-\tfmt.Println(models.CircArea(circle))\n+\t_, _, _ = fmt.Println, models.CircArea, circle\n \tfmt.Println(models.Circumference(circle))\n \tfmt.Println(\"Yabadabadu\")\n \tmodels.PrintShapeDetails(rectangle)\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.94\" with checksum a7ceb817943fb6fb3d451c7a1f0e2c79\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\t_, _, _ = fmt.Println, models.Circumference, circle\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -38,7 +38,7 @@\n \tfmt.Println(models.RectArea(rectangle))\n \tfmt.Println(models.RectPerimeter(rectangle))\n \tfmt.Println(models.CircArea(circle))\n-\tfmt.Println(models.Circumference(circle))\n+\t_, _, _ = fmt.Println, models.Circumference, circle\n \tfmt.Println(\"Yabadabadu\")\n \tmodels.PrintShapeDetails(rectangle)\n \tmodels.PrintShapeDetails(circle)\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.95\" with checksum 821688cca91bb0db39a30b0390f0a6dc\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\t_ = fmt.Println\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -39,7 +39,7 @@\n \tfmt.Println(models.RectPerimeter(rectangle))\n \tfmt.Println(models.CircArea(circle))\n \tfmt.Println(models.Circumference(circle))\n-\tfmt.Println(\"Yabadabadu\")\n+\t_ = fmt.Println\n \tmodels.PrintShapeDetails(rectangle)\n \tmodels.PrintShapeDetails(circle)\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.96\" with checksum 231411e4434f11976d39cd62f6c16ea1\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\t_, _ = models.PrintShapeDetails, rectangle\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -40,7 +40,7 @@\n \tfmt.Println(models.CircArea(circle))\n \tfmt.Println(models.Circumference(circle))\n \tfmt.Println(\"Yabadabadu\")\n-\tmodels.PrintShapeDetails(rectangle)\n+\t_, _ = models.PrintShapeDetails, rectangle\n \tmodels.PrintShapeDetails(circle)\n \n \tname := \"Gencho\"\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.97\" with checksum dd4f109e3ad33a4efcf05a76e30a01e3\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\t_, _ = models.PrintShapeDetails, circle\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -41,7 +41,7 @@\n \tfmt.Println(models.Circumference(circle))\n \tfmt.Println(\"Yabadabadu\")\n \tmodels.PrintShapeDetails(rectangle)\n-\tmodels.PrintShapeDetails(circle)\n+\t_, _ = models.PrintShapeDetails, circle\n \n \tname := \"Gencho\"\n \tfmt.Println(ReverseString(name))\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.98\" with checksum 96f7296bc5b6c44c886d7d2fd966b9ca\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\t_, _ = fmt.Println, name\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -44,7 +44,7 @@\n \tmodels.PrintShapeDetails(circle)\n \n \tname := \"Gencho\"\n-\tfmt.Println(ReverseString(name))\n+\t_, _ = fmt.Println, name\n \n \tperson := models.Person{\n \t\tName:  \"John Doe\",\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.99\" with checksum fe5cab701311867fb571814774746864\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\t_, _ = fmt.Println, jsonPerson\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -53,7 +53,7 @@\n \t}\n \n \tjsonPerson := models.EncodeJSON(person)\n-\tfmt.Println(jsonPerson)\n+\t_, _ = fmt.Println, jsonPerson\n \tfmt.Println(models.DecodeJSON(jsonPerson))\n \n }\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.100\" with checksum a9e1adeffea4998bbffb60818c9989d2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\t_, _, _ = fmt.Println, models.DecodeJSON, jsonPerson\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -54,7 +54,7 @@\n \n \tjsonPerson := models.EncodeJSON(person)\n \tfmt.Println(jsonPerson)\n-\tfmt.Println(models.DecodeJSON(jsonPerson))\n+\t_, _, _ = fmt.Println, models.DecodeJSON, jsonPerson\n \n }\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/main.go.101\" with checksum ad521c1e5b2b4595dcaa2fc18c3b78f9\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width / r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -21,7 +21,7 @@\n }\n \n func RectArea(r Rectangle) float64 {\n-\treturn r.Width * r.Height\n+\treturn r.Width / r.Height\n }\n \n func RectPerimeter(r Rectangle) float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.0\" with checksum 3d15d9a74f163e9b375646c74d412721\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 - r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n }\n \n func RectPerimeter(r Rectangle) float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*2 - r.Height*2\n }\n \n func (r Rectangle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.1\" with checksum 35ea61d985aaac6071c66ac323c81b09\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width/2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n }\n \n func RectPerimeter(r Rectangle) float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width/2 + r.Height*2\n }\n \n func (r Rectangle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.2\" with checksum 74c5c095ed488e761595ca618b705f42\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height/2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n }\n \n func RectPerimeter(r Rectangle) float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*2 + r.Height/2\n }\n \n func (r Rectangle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.3\" with checksum 2b99159ed24eefe2e05e90e082a9b3c4\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi / math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -41,7 +41,7 @@\n }\n \n func CircArea(c Cyrcle) float64 {\n-\treturn math.Pi * math.Pow(c.Radius, 2)\n+\treturn math.Pi / math.Pow(c.Radius, 2)\n }\n \n func Circumference(c Cyrcle) float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.8\" with checksum a39ae143f6918142de4e9285bb5a73fd\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) / math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -45,7 +45,7 @@\n }\n \n func Circumference(c Cyrcle) float64 {\n-\treturn (c.Radius * 2) * math.Pi\n+\treturn (c.Radius * 2) / math.Pi\n }\n \n func (c Cyrcle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.9\" with checksum 60f05e0fe432f9f3f2d0c89e0c63c554\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius / 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -45,7 +45,7 @@\n }\n \n func Circumference(c Cyrcle) float64 {\n-\treturn (c.Radius * 2) * math.Pi\n+\treturn (c.Radius / 2) * math.Pi\n }\n \n func (c Cyrcle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.10\" with checksum 3e2823cc2c096fa48d6a095e836ce9be\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*1 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n }\n \n func RectPerimeter(r Rectangle) float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*1 + r.Height*2\n }\n \n func (r Rectangle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.14\" with checksum 592c125fa3cc9e8337956cbf8153abcb\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*1\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n }\n \n func RectPerimeter(r Rectangle) float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*2 + r.Height*1\n }\n \n func (r Rectangle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.15\" with checksum 6a0089ecc1369aea325193bec3f742ba\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 1)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -41,7 +41,7 @@\n }\n \n func CircArea(c Cyrcle) float64 {\n-\treturn math.Pi * math.Pow(c.Radius, 2)\n+\treturn math.Pi * math.Pow(c.Radius, 1)\n }\n \n func Circumference(c Cyrcle) float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.18\" with checksum 0d59d415ea3ce1d1badde91919da0456\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 1) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -45,7 +45,7 @@\n }\n \n func Circumference(c Cyrcle) float64 {\n-\treturn (c.Radius * 2) * math.Pi\n+\treturn (c.Radius * 1) * math.Pi\n }\n \n func (c Cyrcle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.19\" with checksum 729c0edda3664262697dd873fce001d8\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*3 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n }\n \n func RectPerimeter(r Rectangle) float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*3 + r.Height*2\n }\n \n func (r Rectangle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.22\" with checksum ce0a11196e5f0c364758f4a1ef2357b9\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*3\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n }\n \n func RectPerimeter(r Rectangle) float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*2 + r.Height*3\n }\n \n func (r Rectangle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.23\" with checksum 06d286f6c5c9911f667e2b4301f6f8a6\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 3)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -41,7 +41,7 @@\n }\n \n func CircArea(c Cyrcle) float64 {\n-\treturn math.Pi * math.Pow(c.Radius, 2)\n+\treturn math.Pi * math.Pow(c.Radius, 3)\n }\n \n func Circumference(c Cyrcle) float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.26\" with checksum ce8db30bdb0a72d16460d072a583b1e3\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 3) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -45,7 +45,7 @@\n }\n \n func Circumference(c Cyrcle) float64 {\n-\treturn (c.Radius * 2) * math.Pi\n+\treturn (c.Radius * 3) * math.Pi\n }\n \n func (c Cyrcle) Area() float64 {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.27\" with checksum fc272dd4608ac4f66a2194a64c823184\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\t_, _ = fmt.Println, shape.Area\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -11,7 +11,7 @@\n }\n \n func PrintShapeDetails(shape Shape) {\n-\tfmt.Println(shape.Area())\n+\t_, _ = fmt.Println, shape.Area\n \tfmt.Println(shape.Perimeter())\n }\n \n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.30\" with checksum d80ed58f2f434835c560ced2551995ed\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\t_, _ = fmt.Println, shape.Perimeter\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -12,7 +12,7 @@\n \n func PrintShapeDetails(shape Shape) {\n \tfmt.Println(shape.Area())\n-\tfmt.Println(shape.Perimeter())\n+\t_, _ = fmt.Println, shape.Perimeter\n }\n \n type Rectangle struct {\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/figures.go.31\" with checksum 79fda7a4d73e88942374d62941113e53\n"},{"mutator":{"mutatorName":"arithmetic/assignment","originalSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr = fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","originalFilePath":"src/models/person.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n \n func (p Person) String() string {\n \tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n-\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n+\tstr = fmt.Sprintf(\"Age: %d\\n\", p.Age)\n \tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n \treturn str\n }\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/person.go.2\" with checksum 1029603ef44da1eb6ccc09adfdc8e23e\n"},{"mutator":{"mutatorName":"arithmetic/assignment","originalSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr = fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","originalFilePath":"src/models/person.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -34,6 +34,6 @@\n func (p Person) String() string {\n \tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n \tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n-\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n+\tstr = fmt.Sprintf(\"Email: %s\\n\", p.Email)\n \treturn str\n }\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/person.go.3\" with checksum a548b5dd3b2b45e66379bf83c6f6bf0c\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\t_ = fmt.Println\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","originalFilePath":"src/models/person.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -14,7 +14,7 @@\n func EncodeJSON(p Person) []byte {\n \tjsonPerson, err := json.Marshal(p)\n \tif err != nil {\n-\t\tfmt.Println(\"Error with encoding Person to JSON\")\n+\t\t_ = fmt.Println\n \t}\n \n \treturn jsonPerson\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/person.go.4\" with checksum 2ccf6c169771ba70c8b4a8928a7ad9e4\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\t_ = fmt.Println\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","originalFilePath":"src/models/person.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -25,7 +25,7 @@\n \n \terr := json.Unmarshal(j, \u0026resPers)\n \tif err != nil {\n-\t\tfmt.Println(\"Error with decoding Person from JSON\")\n+\t\t_ = fmt.Println\n \t}\n \n \treturn resPers\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/person.go.5\" with checksum c52c8b4efac450ab7386ed587da64fbd\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\t_, _, _ = str, fmt.Sprintf, p.Age\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","originalFilePath":"src/models/person.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n \n func (p Person) String() string {\n \tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n-\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n+\t_, _, _ = str, fmt.Sprintf, p.Age\n \tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n \treturn str\n }\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/person.go.8\" with checksum 0b0482ab00c6cbaeee02302293c6edf0\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\t_, _, _ = str, fmt.Sprintf, p.Email\n\treturn str\n}\n","originalFilePath":"src/models/person.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -34,6 +34,6 @@\n func (p Person) String() string {\n \tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n \tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n-\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n+\t_, _, _ = str, fmt.Sprintf, p.Email\n \treturn str\n }\n","processOutput":"FAIL \"/tmp/go-mutesting-1976548713/src/models/person.go.9\" with checksum d5ce0a06d5114a2783c4f20c6dfc8292\n"}],"timeouted":null,"killed":[{"mutator":{"mutatorName":"arithmetic/assign_invert","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr -= string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -61,7 +61,7 @@\n func ReverseString(str string) string {\n \tnewStr := \"\"\n \tfor i := len(str) - 1; i \u003e= 0; i-- {\n-\t\tnewStr += string([]rune(str)[i])\n+\t\tnewStr -= string([]rune(str)[i])\n \t}\n \treturn newStr\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.0\" with checksum a5b1d5d97710c9cf973a1ea80c47effd\n"},{"mutator":{"mutatorName":"arithmetic/assign_invert","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] -= mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -109,7 +109,7 @@\n \tfor keyString := range mapB {\n \t\t_, isCont := mapA[keyString]\n \t\tif isCont {\n-\t\t\tmapA[keyString] += mapB[keyString]\n+\t\t\tmapA[keyString] -= mapB[keyString]\n \t\t} else {\n \t\t\tmapA[keyString] = mapB[keyString]\n \t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.1\" with checksum be74a54178a007845df1bb83b41108dc\n"},{"mutator":{"mutatorName":"arithmetic/assignment","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr = string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -61,7 +61,7 @@\n func ReverseString(str string) string {\n \tnewStr := \"\"\n \tfor i := len(str) - 1; i \u003e= 0; i-- {\n-\t\tnewStr += string([]rune(str)[i])\n+\t\tnewStr = string([]rune(str)[i])\n \t}\n \treturn newStr\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.2\" with checksum 7ed4904ca3e950ad6ac4a6f8c9e5351b\n"},{"mutator":{"mutatorName":"arithmetic/assignment","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -109,7 +109,7 @@\n \tfor keyString := range mapB {\n \t\t_, isCont := mapA[keyString]\n \t\tif isCont {\n-\t\t\tmapA[keyString] += mapB[keyString]\n+\t\t\tmapA[keyString] = mapB[keyString]\n \t\t} else {\n \t\t\tmapA[keyString] = mapB[keyString]\n \t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.3\" with checksum c00b6953292d0e02b588f5bcaecf30ce\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) + 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -60,7 +60,7 @@\n \n func ReverseString(str string) string {\n \tnewStr := \"\"\n-\tfor i := len(str) - 1; i \u003e= 0; i-- {\n+\tfor i := len(str) + 1; i \u003e= 0; i-- {\n \t\tnewStr += string([]rune(str)[i])\n \t}\n \treturn newStr\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.4\" with checksum 3c75dc53afb5709defe4acaec1a8ff0e\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] - 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -96,7 +96,7 @@\n \tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n \t\t_, isCont := intOccMap[sliceOfStrings[i]]\n \t\tif isCont {\n-\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n+\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] - 1\n \t\t} else {\n \t\t\tintOccMap[sliceOfStrings[i]] = 1\n \t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.5\" with checksum 10fb2a5ceff3a1b32508e164318d059c\n"},{"mutator":{"mutatorName":"branch/else","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\t_, _, _ = intOccMap, sliceOfStrings, i\n\t\t}\n\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -98,8 +98,9 @@\n \t\tif isCont {\n \t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n \t\t} else {\n-\t\t\tintOccMap[sliceOfStrings[i]] = 1\n+\t\t\t_, _, _ = intOccMap, sliceOfStrings, i\n \t\t}\n+\n \t}\n \n \treturn intOccMap\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.6\" with checksum 7b2c8b7de45010261dae94271462917d\n"},{"mutator":{"mutatorName":"branch/else","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\t_, _, _, _ = mapA, keyString, mapB, keyString\n\t\t}\n\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -111,8 +111,9 @@\n \t\tif isCont {\n \t\t\tmapA[keyString] += mapB[keyString]\n \t\t} else {\n-\t\t\tmapA[keyString] = mapB[keyString]\n+\t\t\t_, _, _, _ = mapA, keyString, mapB, keyString\n \t\t}\n+\n \t}\n \treturn mapA\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.7\" with checksum 80e1ff315577f96a81aed0cd13e31cc8\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -69,7 +69,7 @@\n func removeDuplicates(sliceOfInts []int) []int {\n \n \tif len(sliceOfInts) == 0 {\n-\t\treturn []int{}\n+\n \t}\n \n \tnewSliceOfInt := []int{}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.8\" with checksum 1a1985d105996cfe43f5786b7ed9519b\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\t_ = isDuplicate\n\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -80,8 +80,8 @@\n \t\tisDuplicate = false\n \t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n-\t\t\t\tisDuplicate = true\n-\t\t\t\tbreak\n+\t\t\t\t_ = isDuplicate\n+\n \t\t\t}\n \t\t}\n \t\tif !isDuplicate {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.9\" with checksum bc97647547eb0e5b132341d64c08017c\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\t_, _, _, _ = newSliceOfInt, newSliceOfInt, sliceOfInts, i\n\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -85,7 +85,8 @@\n \t\t\t}\n \t\t}\n \t\tif !isDuplicate {\n-\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n+\t\t\t_, _, _, _ = newSliceOfInt, newSliceOfInt, sliceOfInts, i\n+\n \t\t}\n \t}\n \treturn newSliceOfInt\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.10\" with checksum fb36ebbbc5678d3c9c645b381c3b2d58\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\t_, _, _, _, _, _ = intOccMap, sliceOfStrings, i, intOccMap, sliceOfStrings, i\n\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -96,7 +96,8 @@\n \tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n \t\t_, isCont := intOccMap[sliceOfStrings[i]]\n \t\tif isCont {\n-\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n+\t\t\t_, _, _, _, _, _ = intOccMap, sliceOfStrings, i, intOccMap, sliceOfStrings, i\n+\n \t\t} else {\n \t\t\tintOccMap[sliceOfStrings[i]] = 1\n \t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.11\" with checksum 25715ba30eb118380159bcde8bdc7cb6\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\t_, _, _, _ = mapA, keyString, mapB, keyString\n\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -109,7 +109,8 @@\n \tfor keyString := range mapB {\n \t\t_, isCont := mapA[keyString]\n \t\tif isCont {\n-\t\t\tmapA[keyString] += mapB[keyString]\n+\t\t\t_, _, _, _ = mapA, keyString, mapB, keyString\n+\n \t\t} else {\n \t\t\tmapA[keyString] = mapB[keyString]\n \t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.12\" with checksum 0fdfb6fce0ccef5cf47a36f4463d7937\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -60,7 +60,7 @@\n \n func ReverseString(str string) string {\n \tnewStr := \"\"\n-\tfor i := len(str) - 1; i \u003e= 0; i-- {\n+\tfor i := len(str) - 1; i \u003e 0; i-- {\n \t\tnewStr += string([]rune(str)[i])\n \t}\n \treturn newStr\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.13\" with checksum 9d637c6a4657ca71803d3dde4e7a3bc2\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c= len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -76,7 +76,7 @@\n \tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n \tvar isDuplicate bool\n \n-\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n+\tfor i := 1; i \u003c= len(sliceOfInts); i++ {\n \t\tisDuplicate = false\n \t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.14\" with checksum 222ccb6706ef0f521c96bcdfa9d6d47b\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c= len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -78,7 +78,7 @@\n \n \tfor i := 1; i \u003c len(sliceOfInts); i++ {\n \t\tisDuplicate = false\n-\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n+\t\tfor j := 0; j \u003c= len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n \t\t\t\tisDuplicate = true\n \t\t\t\tbreak\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.15\" with checksum e0a3e2715530affb2e9edc824456579f\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c= len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -93,7 +93,7 @@\n \n func countOccurrences(sliceOfStrings []string) map[string]int {\n \tintOccMap := make(map[string]int)\n-\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n+\tfor i := 0; i \u003c= len(sliceOfStrings); i++ {\n \t\t_, isCont := intOccMap[sliceOfStrings[i]]\n \t\tif isCont {\n \t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.16\" with checksum c7de3555736f1e70b42d2f22000dfe02\n"},{"mutator":{"mutatorName":"loop/condition","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; 1 \u003c 1; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -60,7 +60,7 @@\n \n func ReverseString(str string) string {\n \tnewStr := \"\"\n-\tfor i := len(str) - 1; i \u003e= 0; i-- {\n+\tfor i := len(str) - 1; 1 \u003c 1; i-- {\n \t\tnewStr += string([]rune(str)[i])\n \t}\n \treturn newStr\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.18\" with checksum 3be40c8b344d7ff21184dd2d4059063a\n"},{"mutator":{"mutatorName":"loop/condition","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; 1 \u003c 1; i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -76,7 +76,7 @@\n \tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n \tvar isDuplicate bool\n \n-\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n+\tfor i := 1; 1 \u003c 1; i++ {\n \t\tisDuplicate = false\n \t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.19\" with checksum 4e3175a1f19a9e05b3074f55193f0f5b\n"},{"mutator":{"mutatorName":"loop/condition","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; 1 \u003c 1; j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -78,7 +78,7 @@\n \n \tfor i := 1; i \u003c len(sliceOfInts); i++ {\n \t\tisDuplicate = false\n-\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n+\t\tfor j := 0; 1 \u003c 1; j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n \t\t\t\tisDuplicate = true\n \t\t\t\tbreak\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.20\" with checksum 3e1b1dff140d31ac494dacb914bf5be5\n"},{"mutator":{"mutatorName":"loop/condition","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; 1 \u003c 1; i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -93,7 +93,7 @@\n \n func countOccurrences(sliceOfStrings []string) map[string]int {\n \tintOccMap := make(map[string]int)\n-\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n+\tfor i := 0; 1 \u003c 1; i++ {\n \t\t_, isCont := intOccMap[sliceOfStrings[i]]\n \t\tif isCont {\n \t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.21\" with checksum 4512d386344ed1249063aac57c4d5dc4\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\tbreak\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -107,6 +107,7 @@\n \n func mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n \tfor keyString := range mapB {\n+\t\tbreak\n \t\t_, isCont := mapA[keyString]\n \t\tif isCont {\n \t\t\tmapA[keyString] += mapB[keyString]\n@@ -114,5 +115,6 @@\n \t\t\tmapA[keyString] = mapB[keyString]\n \t\t}\n \t}\n+\n \treturn mapA\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.22\" with checksum 1f228a8279117839c9eea799c35b0c5f\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 0; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -60,7 +60,7 @@\n \n func ReverseString(str string) string {\n \tnewStr := \"\"\n-\tfor i := len(str) - 1; i \u003e= 0; i-- {\n+\tfor i := len(str) - 0; i \u003e= 0; i-- {\n \t\tnewStr += string([]rune(str)[i])\n \t}\n \treturn newStr\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.47\" with checksum ef5025ed5a97e4bb1643dd4d88888933\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= -1; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -60,7 +60,7 @@\n \n func ReverseString(str string) string {\n \tnewStr := \"\"\n-\tfor i := len(str) - 1; i \u003e= 0; i-- {\n+\tfor i := len(str) - 1; i \u003e= -1; i-- {\n \t\tnewStr += string([]rune(str)[i])\n \t}\n \treturn newStr\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.48\" with checksum fcba3ec617ae6f34a82e5e48e7596b47\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == -1 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -68,7 +68,7 @@\n \n func removeDuplicates(sliceOfInts []int) []int {\n \n-\tif len(sliceOfInts) == 0 {\n+\tif len(sliceOfInts) == -1 {\n \t\treturn []int{}\n \t}\n \n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.49\" with checksum 1d0868e475b4420047775144d9f921a3\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[-1])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -73,7 +73,7 @@\n \t}\n \n \tnewSliceOfInt := []int{}\n-\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n+\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[-1])\n \tvar isDuplicate bool\n \n \tfor i := 1; i \u003c len(sliceOfInts); i++ {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.50\" with checksum 5dc8045c3eeb428bdfb706154417ccf1\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := -1; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -78,7 +78,7 @@\n \n \tfor i := 1; i \u003c len(sliceOfInts); i++ {\n \t\tisDuplicate = false\n-\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n+\t\tfor j := -1; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n \t\t\t\tisDuplicate = true\n \t\t\t\tbreak\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.52\" with checksum dcf88d03b826629e0ae82811910ca598\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := -1; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -93,7 +93,7 @@\n \n func countOccurrences(sliceOfStrings []string) map[string]int {\n \tintOccMap := make(map[string]int)\n-\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n+\tfor i := -1; i \u003c len(sliceOfStrings); i++ {\n \t\t_, isCont := intOccMap[sliceOfStrings[i]]\n \t\tif isCont {\n \t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.53\" with checksum e9a10f2742e7178b185f2ce0ea8a6590\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 0\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -96,7 +96,7 @@\n \tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n \t\t_, isCont := intOccMap[sliceOfStrings[i]]\n \t\tif isCont {\n-\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n+\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 0\n \t\t} else {\n \t\t\tintOccMap[sliceOfStrings[i]] = 1\n \t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.54\" with checksum c9257ce6678811d5e7a628ea6cf958bf\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 0\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -98,7 +98,7 @@\n \t\tif isCont {\n \t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n \t\t} else {\n-\t\t\tintOccMap[sliceOfStrings[i]] = 1\n+\t\t\tintOccMap[sliceOfStrings[i]] = 0\n \t\t}\n \t}\n \n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.55\" with checksum d51f31fcb3b85f9bea8c5b4632595b60\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 2; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -60,7 +60,7 @@\n \n func ReverseString(str string) string {\n \tnewStr := \"\"\n-\tfor i := len(str) - 1; i \u003e= 0; i-- {\n+\tfor i := len(str) - 2; i \u003e= 0; i-- {\n \t\tnewStr += string([]rune(str)[i])\n \t}\n \treturn newStr\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.80\" with checksum c614f2d923264a7d331e9bf3d46e47b6\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 1; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -60,7 +60,7 @@\n \n func ReverseString(str string) string {\n \tnewStr := \"\"\n-\tfor i := len(str) - 1; i \u003e= 0; i-- {\n+\tfor i := len(str) - 1; i \u003e= 1; i-- {\n \t\tnewStr += string([]rune(str)[i])\n \t}\n \treturn newStr\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.81\" with checksum 1f6f87160b2760d70f840c470f1e2cd9\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 1 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -68,7 +68,7 @@\n \n func removeDuplicates(sliceOfInts []int) []int {\n \n-\tif len(sliceOfInts) == 0 {\n+\tif len(sliceOfInts) == 1 {\n \t\treturn []int{}\n \t}\n \n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.82\" with checksum dd8633d92e25f93edb0d5dd5c81f89ad\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[1])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -73,7 +73,7 @@\n \t}\n \n \tnewSliceOfInt := []int{}\n-\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n+\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[1])\n \tvar isDuplicate bool\n \n \tfor i := 1; i \u003c len(sliceOfInts); i++ {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.83\" with checksum 4c62f622b51eb0f0ed1438b05313c4e8\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 2; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -76,7 +76,7 @@\n \tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n \tvar isDuplicate bool\n \n-\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n+\tfor i := 2; i \u003c len(sliceOfInts); i++ {\n \t\tisDuplicate = false\n \t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.84\" with checksum 91d45f301579a6450ca8cce9c8e98d15\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 1; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -93,7 +93,7 @@\n \n func countOccurrences(sliceOfStrings []string) map[string]int {\n \tintOccMap := make(map[string]int)\n-\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n+\tfor i := 1; i \u003c len(sliceOfStrings); i++ {\n \t\t_, isCont := intOccMap[sliceOfStrings[i]]\n \t\tif isCont {\n \t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.86\" with checksum b3766e2ec444ffe457235810e1e262af\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 2\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -96,7 +96,7 @@\n \tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n \t\t_, isCont := intOccMap[sliceOfStrings[i]]\n \t\tif isCont {\n-\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n+\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 2\n \t\t} else {\n \t\t\tintOccMap[sliceOfStrings[i]] = 1\n \t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.87\" with checksum b528e7303495a12dc9550a90cceb7f94\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 2\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -98,7 +98,7 @@\n \t\tif isCont {\n \t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n \t\t} else {\n-\t\t\tintOccMap[sliceOfStrings[i]] = 1\n+\t\t\tintOccMap[sliceOfStrings[i]] = 2\n \t\t}\n \t}\n \n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.88\" with checksum 17808bd3c6a5bbb204ca2df5a6d8b177\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\t_, _, _ = newStr, str, i\n\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -61,7 +61,8 @@\n func ReverseString(str string) string {\n \tnewStr := \"\"\n \tfor i := len(str) - 1; i \u003e= 0; i-- {\n-\t\tnewStr += string([]rune(str)[i])\n+\t\t_, _, _ = newStr, str, i\n+\n \t}\n \treturn newStr\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.102\" with checksum 5b0fd3c3c75d72ed4e6faaf220b03d26\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\t_, _, _ = newSliceOfInt, newSliceOfInt, sliceOfInts\n\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -73,7 +73,8 @@\n \t}\n \n \tnewSliceOfInt := []int{}\n-\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n+\t_, _, _ = newSliceOfInt, newSliceOfInt, sliceOfInts\n+\n \tvar isDuplicate bool\n \n \tfor i := 1; i \u003c len(sliceOfInts); i++ {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.103\" with checksum 7733f2f43b6646e5774d69780d3e3583\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\t_ = isDuplicate\n\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -77,7 +77,8 @@\n \tvar isDuplicate bool\n \n \tfor i := 1; i \u003c len(sliceOfInts); i++ {\n-\t\tisDuplicate = false\n+\t\t_ = isDuplicate\n+\n \t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n \t\t\t\tisDuplicate = true\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.104\" with checksum d1ccf5058b9f01a1faa9c5d10153fa38\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\t_ = isDuplicate\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -80,7 +80,8 @@\n \t\tisDuplicate = false\n \t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n \t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n-\t\t\t\tisDuplicate = true\n+\t\t\t\t_ = isDuplicate\n+\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.105\" with checksum 9cb69f6e6286bd981105b8663806cdbe\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\t_, _, _ = intOccMap, sliceOfStrings, i\n\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -98,7 +98,8 @@\n \t\tif isCont {\n \t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n \t\t} else {\n-\t\t\tintOccMap[sliceOfStrings[i]] = 1\n+\t\t\t_, _, _ = intOccMap, sliceOfStrings, i\n+\n \t\t}\n \t}\n \n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.108\" with checksum 39d9b9a6f7f15e47b00d1ad6a2f0bf88\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\tmapA[keyString] = mapB[keyString]\n\t\t}\n\t}\n\treturn mapA\n}\n","mutatedSourceCode":"package main\n\nimport (\n\t\"fmt\"\n\t\"go-basic-tasks/src/models\"\n)\n\nfunc main() {\n\tsliceOfInt := []int{1, 1, 2, 3, 0, 5, 7, 3, 5, 4, 8, 90}\n\tsliceOfStr := []string{\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"}\n\n\tmapA := map[string]int{\n\t\t\"apple\":  5,\n\t\t\"banana\": 3,\n\t\t\"orange\": 2,\n\t\t\"peach\":  4,\n\t}\n\n\tmapB := map[string]int{\n\t\t\"apple\":   3,\n\t\t\"orange\":  2,\n\t\t\"tomatoe\": 12,\n\t\t\"coconut\": 1,\n\t}\n\n\trectangle := models.Rectangle{\n\t\tWidth:  124,\n\t\tHeight: 351,\n\t}\n\n\tcircle := models.Cyrcle{\n\t\tRadius: 34,\n\t}\n\n\tfmt.Println(removeDuplicates(sliceOfInt))\n\tfmt.Println(countOccurrences(sliceOfStr))\n\tfmt.Println(mergeMaps(mapA, mapB))\n\tfmt.Println(models.RectArea(rectangle))\n\tfmt.Println(models.RectPerimeter(rectangle))\n\tfmt.Println(models.CircArea(circle))\n\tfmt.Println(models.Circumference(circle))\n\tfmt.Println(\"Yabadabadu\")\n\tmodels.PrintShapeDetails(rectangle)\n\tmodels.PrintShapeDetails(circle)\n\n\tname := \"Gencho\"\n\tfmt.Println(ReverseString(name))\n\n\tperson := models.Person{\n\t\tName:  \"John Doe\",\n\t\tAge:   25,\n\t\tEmail: \"johndoe@example.org\",\n\t}\n\n\tjsonPerson := models.EncodeJSON(person)\n\tfmt.Println(jsonPerson)\n\tfmt.Println(models.DecodeJSON(jsonPerson))\n\n}\n\nfunc ReverseString(str string) string {\n\tnewStr := \"\"\n\tfor i := len(str) - 1; i \u003e= 0; i-- {\n\t\tnewStr += string([]rune(str)[i])\n\t}\n\treturn newStr\n}\n\nfunc removeDuplicates(sliceOfInts []int) []int {\n\n\tif len(sliceOfInts) == 0 {\n\t\treturn []int{}\n\t}\n\n\tnewSliceOfInt := []int{}\n\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[0])\n\tvar isDuplicate bool\n\n\tfor i := 1; i \u003c len(sliceOfInts); i++ {\n\t\tisDuplicate = false\n\t\tfor j := 0; j \u003c len(newSliceOfInt); j++ {\n\t\t\tif sliceOfInts[i] == newSliceOfInt[j] {\n\t\t\t\tisDuplicate = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isDuplicate {\n\t\t\tnewSliceOfInt = append(newSliceOfInt, sliceOfInts[i])\n\t\t}\n\t}\n\treturn newSliceOfInt\n}\n\nfunc countOccurrences(sliceOfStrings []string) map[string]int {\n\tintOccMap := make(map[string]int)\n\tfor i := 0; i \u003c len(sliceOfStrings); i++ {\n\t\t_, isCont := intOccMap[sliceOfStrings[i]]\n\t\tif isCont {\n\t\t\tintOccMap[sliceOfStrings[i]] = intOccMap[sliceOfStrings[i]] + 1\n\t\t} else {\n\t\t\tintOccMap[sliceOfStrings[i]] = 1\n\t\t}\n\t}\n\n\treturn intOccMap\n}\n\nfunc mergeMaps(mapA map[string]int, mapB map[string]int) map[string]int {\n\tfor keyString := range mapB {\n\t\t_, isCont := mapA[keyString]\n\t\tif isCont {\n\t\t\tmapA[keyString] += mapB[keyString]\n\t\t} else {\n\t\t\t_, _, _, _ = mapA, keyString, mapB, keyString\n\n\t\t}\n\t}\n\treturn mapA\n}\n","originalFilePath":"main.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -111,7 +111,8 @@\n \t\tif isCont {\n \t\t\tmapA[keyString] += mapB[keyString]\n \t\t} else {\n-\t\t\tmapA[keyString] = mapB[keyString]\n+\t\t\t_, _, _, _ = mapA, keyString, mapB, keyString\n+\n \t\t}\n \t}\n \treturn mapA\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/main.go.110\" with checksum 9404d842ef0683ebe362c2b24b34af0c\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width / r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -29,7 +29,7 @@\n }\n \n func (r Rectangle) Area() float64 {\n-\treturn r.Width * r.Height\n+\treturn r.Width / r.Height\n }\n \n func (r Rectangle) Perimeter() float64 {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.4\" with checksum 631cb7cc2094c273e0affe355ec07352\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 - r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n }\n \n func (r Rectangle) Perimeter() float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*2 - r.Height*2\n }\n \n type Cyrcle struct {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.5\" with checksum 55287fa688aa023a3735220eef78bfd3\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width/2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n }\n \n func (r Rectangle) Perimeter() float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width/2 + r.Height*2\n }\n \n type Cyrcle struct {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.6\" with checksum 722ecd6043c88fb8b02f2726a1f23174\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height/2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n }\n \n func (r Rectangle) Perimeter() float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*2 + r.Height/2\n }\n \n type Cyrcle struct {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.7\" with checksum a123ab6a276b3546e972cf6086414e3a\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi / math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -49,7 +49,7 @@\n }\n \n func (c Cyrcle) Area() float64 {\n-\treturn math.Pi * math.Pow(c.Radius, 2)\n+\treturn math.Pi / math.Pow(c.Radius, 2)\n }\n \n func (c Cyrcle) Perimeter() float64 {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.11\" with checksum 4d1123e57e0a21978bee3aed950f8d9a\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) / math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -53,5 +53,5 @@\n }\n \n func (c Cyrcle) Perimeter() float64 {\n-\treturn (c.Radius * 2) * math.Pi\n+\treturn (c.Radius * 2) / math.Pi\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.12\" with checksum cbe4bddff2840d934f90596ecdef78f3\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius / 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -53,5 +53,5 @@\n }\n \n func (c Cyrcle) Perimeter() float64 {\n-\treturn (c.Radius * 2) * math.Pi\n+\treturn (c.Radius / 2) * math.Pi\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.13\" with checksum 05547787ab451458afd2e35b4342466c\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*1 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n }\n \n func (r Rectangle) Perimeter() float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*1 + r.Height*2\n }\n \n type Cyrcle struct {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.16\" with checksum a16f6c84db998ce1435ee49d9976570b\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*1\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n }\n \n func (r Rectangle) Perimeter() float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*2 + r.Height*1\n }\n \n type Cyrcle struct {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.17\" with checksum 048c3abc23a16dc6a8e4370680f775d0\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 1)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -49,7 +49,7 @@\n }\n \n func (c Cyrcle) Area() float64 {\n-\treturn math.Pi * math.Pow(c.Radius, 2)\n+\treturn math.Pi * math.Pow(c.Radius, 1)\n }\n \n func (c Cyrcle) Perimeter() float64 {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.20\" with checksum eccaa9c49a808d5563c64810d437994b\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 1) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -53,5 +53,5 @@\n }\n \n func (c Cyrcle) Perimeter() float64 {\n-\treturn (c.Radius * 2) * math.Pi\n+\treturn (c.Radius * 1) * math.Pi\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.21\" with checksum d74f650b21fa49f097ad1cd5d25a73c2\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*3 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n }\n \n func (r Rectangle) Perimeter() float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*3 + r.Height*2\n }\n \n type Cyrcle struct {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.24\" with checksum 3fdfc24d65822d89e30d4f613bb79b7d\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*3\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n }\n \n func (r Rectangle) Perimeter() float64 {\n-\treturn r.Width*2 + r.Height*2\n+\treturn r.Width*2 + r.Height*3\n }\n \n type Cyrcle struct {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.25\" with checksum 320fdffbc1f695008d0a2dc364cd96e5\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 3)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -49,7 +49,7 @@\n }\n \n func (c Cyrcle) Area() float64 {\n-\treturn math.Pi * math.Pow(c.Radius, 2)\n+\treturn math.Pi * math.Pow(c.Radius, 3)\n }\n \n func (c Cyrcle) Perimeter() float64 {\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.28\" with checksum cc94dbdda32d92a9fa011135010fe7df\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\nfunc PrintShapeDetails(shape Shape) {\n\tfmt.Println(shape.Area())\n\tfmt.Println(shape.Perimeter())\n}\n\ntype Rectangle struct {\n\tWidth  float64\n\tHeight float64\n}\n\nfunc RectArea(r Rectangle) float64 {\n\treturn r.Width * r.Height\n}\n\nfunc RectPerimeter(r Rectangle) float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n\treturn r.Width*2 + r.Height*2\n}\n\ntype Cyrcle struct {\n\tRadius float64\n}\n\nfunc CircArea(c Cyrcle) float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc Circumference(c Cyrcle) float64 {\n\treturn (c.Radius * 2) * math.Pi\n}\n\nfunc (c Cyrcle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\nfunc (c Cyrcle) Perimeter() float64 {\n\treturn (c.Radius * 3) * math.Pi\n}\n","originalFilePath":"src/models/figures.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -53,5 +53,5 @@\n }\n \n func (c Cyrcle) Perimeter() float64 {\n-\treturn (c.Radius * 2) * math.Pi\n+\treturn (c.Radius * 3) * math.Pi\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/figures.go.29\" with checksum e74105c10dd5415e4006e73b54f4f2ae\n"},{"mutator":{"mutatorName":"arithmetic/assign_invert","originalSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr -= fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","originalFilePath":"src/models/person.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -33,7 +33,7 @@\n \n func (p Person) String() string {\n \tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n-\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n+\tstr -= fmt.Sprintf(\"Age: %d\\n\", p.Age)\n \tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n \treturn str\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/person.go.0\" with checksum bffa851a93b55e2542ac8824d8fb8b9e\n"},{"mutator":{"mutatorName":"arithmetic/assign_invert","originalSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","mutatedSourceCode":"package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName  string\n\tAge   int\n\tEmail string\n}\n\nfunc EncodeJSON(p Person) []byte {\n\tjsonPerson, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Error with encoding Person to JSON\")\n\t}\n\n\treturn jsonPerson\n}\n\nfunc DecodeJSON(j []byte) Person {\n\tvar resPers Person\n\n\terr := json.Unmarshal(j, \u0026resPers)\n\tif err != nil {\n\t\tfmt.Println(\"Error with decoding Person from JSON\")\n\t}\n\n\treturn resPers\n}\n\nfunc (p Person) String() string {\n\tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n\tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n\tstr -= fmt.Sprintf(\"Email: %s\\n\", p.Email)\n\treturn str\n}\n","originalFilePath":"src/models/person.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -34,6 +34,6 @@\n func (p Person) String() string {\n \tstr := fmt.Sprintf(\"\\nName: %s\\n\", p.Name)\n \tstr += fmt.Sprintf(\"Age: %d\\n\", p.Age)\n-\tstr += fmt.Sprintf(\"Email: %s\\n\", p.Email)\n+\tstr -= fmt.Sprintf(\"Email: %s\\n\", p.Email)\n \treturn str\n }\n","processOutput":"PASS \"/tmp/go-mutesting-1976548713/src/models/person.go.1\" with checksum 0ee5af8c94d6c493f9d9b56d30c063e7\n"}],"errored":null}